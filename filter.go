package leveldb

import (
	"bytes"

	"github.com/kezhuw/leveldb/internal/bloom"
	"github.com/kezhuw/leveldb/internal/filter"
)

// Filter defines methods to create a small summarized data from large set
// of keys, and check whether a key is possibly contained in the summarized
// data. Many goroutines may call methods of this filter concurrently.
type Filter interface {
	// Name returns the name of this filter.
	//
	// Note that if the encoding of filter data changes in an incompatible
	// way, the name returned by this method must be changed. Otherwise,
	// old incompatible filter data may be passed to methods of this filter.
	Name() string

	// Append appends filter data summarized from keys to buf.
	Append(buf *bytes.Buffer, keys [][]byte)

	// Contains returns a boolean indicating whether key is possibly
	// falling in 'data', which is generated by Generator.
	Contains(data, key []byte) bool

	// NewGenerator creates a new generator to generate filter data
	// for bunch of keys. This method is optional, an implementation
	// can safely return nil, in this case, a fallback generator is
	// created.
	NewGenerator() Generator
}

// Generator is a filter data generator.
type Generator interface {
	// Name returns the name of underlying filter.
	Name() string

	// Reset resets generator to its initial state.
	Reset()

	// Empty returns whether any key has been added to this generator.
	Empty() bool

	// Add adds key to this generator for summarization.
	Add(key []byte)

	// Append appends filter data summarized from keys added before.
	Append(buf *bytes.Buffer)
}

type internalFilter struct {
	filter.Filter
}

func (f internalFilter) NewGenerator() Generator {
	return f.Filter.NewGenerator()
}

type wrappedFilter struct {
	Filter
}

func (f wrappedFilter) NewGenerator() filter.Generator {
	return f.Filter.NewGenerator()
}

// NewBloomFilter creates a bloom filter using bits per key approximately to
// the specified number. Bloom filters using different bitsPerKey are compatible
// with each other. So it is ok to open a database created with bloom filter
// using different bitsPerKey.
func NewBloomFilter(bitsPerKey int) Filter {
	return &internalFilter{bloom.NewFilter(bitsPerKey)}
}

var _ Filter = internalFilter{}
var _ filter.Filter = wrappedFilter{}
var _ Generator = (filter.Generator)(nil)
