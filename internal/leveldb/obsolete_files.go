package leveldb

import (
	"path/filepath"

	"github.com/kezhuw/leveldb/internal/files"
)

func (db *DB) updateObsoleteTableNumber(current, next uint64) uint64 {
	if next == 0 {
		return db.manifest.NextFileNumber()
	}
	if next > current {
		return next
	}
	return current
}

// removeObsoleteFilesAsync send request to delete obsolete files.
// nextTableNumber must be the smallest table file number all ongoing
// compactions could generated or zero if there is no compaction or compaction
// registration in progress.
func (db *DB) removeObsoleteFilesAsync(nextTableNumber uint64) {
	if nextTableNumber == 0 {
		// There is no compaction in progress, but new compactions is
		// likelihood. To prevent deletion of table files from future
		// compactions, we use NextFileNumber as nextTableNumber, this
		// is guarantee to work because all table files generated by
		// future compactions have file number >= NextFileNumber
		// retrieved at this point.
		nextTableNumber = db.manifest.NextFileNumber()
	}
	db.obsoleteFilesChan <- nextTableNumber
}

// removeObsoleteFiles removes obsolete files in database directory. If done is not nil,
// it will be closed after done.
func (db *DB) removeObsoleteFiles(tableNumber, logNumber, manifestNumber uint64, done chan struct{}) {
	if done != nil {
		defer close(done)
	}
	lives := db.manifest.AddLiveFiles(make(map[uint64]struct{}))
	filenames, _ := db.fs.List(db.name)
	for _, name := range filenames {
		kind, number := files.Parse(name)
		switch kind {
		case files.Invalid, files.Lock, files.Current, files.InfoLog, files.Temp:
			continue
		case files.Log:
			if number >= logNumber {
				continue
			}
		case files.Table, files.SSTTable:
			if _, ok := lives[number]; ok || number >= tableNumber {
				continue
			}
		case files.Manifest:
			if number >= manifestNumber {
				continue
			}
		}
		db.fs.Remove(filepath.Join(db.name, name))
	}
}
