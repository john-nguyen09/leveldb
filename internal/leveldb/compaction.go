package leveldb

import (
	"github.com/kezhuw/leveldb/internal/compaction"
	"github.com/kezhuw/leveldb/internal/compactor"
	"github.com/kezhuw/leveldb/internal/configs"
	"github.com/kezhuw/leveldb/internal/files"
	"github.com/kezhuw/leveldb/internal/manifest"
	"github.com/kezhuw/leveldb/internal/memtable"
)

type compactionResult struct {
	err     error
	level   int
	edit    *manifest.Edit
	version *manifest.Version
}

type compactionEdit struct {
	level int
	edit  *manifest.Edit
}

func (db *DB) tryCompactFile(file manifest.LevelFileMeta) {
	select {
	case db.compactionFile <- file:
	default:
	}
}

func (db *DB) compact(c compactor.Compactor, edit *manifest.Edit) {
	level, err := c.Level(), c.Compact(edit)
	if err != nil {
		db.compactionResult <- compactionResult{level: level, err: err}
		return
	}
	if level == -1 {
		db.memtableEdit <- edit
		return
	}
	db.compactionEdit <- compactionEdit{level: level, edit: edit}
}

func (db *DB) startMemTableCompaction(registry *compaction.Registry, mem *memtable.MemTable) bool {
	registration := registry.Register(-1, 0)
	if registration == nil {
		return false
	}
	m := db.manifest
	fileNumber, nextFileNumber := m.NewFileNumber()
	fileName := files.TableFileName(db.name, fileNumber)
	lastSequence := m.LastSequence()
	compactor := compactor.NewMemTableCompactor(fileNumber, fileName, db.getSmallestSnapshot(), mem, db.options)
	edit := &manifest.Edit{
		LogNumber:      db.logNumber,
		NextFileNumber: nextFileNumber,
		LastSequence:   lastSequence,
	}
	registration.NextFileNumber = fileNumber
	go db.compact(compactor, edit)
	return true
}

func (db *DB) startLevelCompactions(compactions []*manifest.Compaction) {
	if len(compactions) == 0 {
		return
	}
	lastSequence := db.manifest.LastSequence()
	smallestSequence := db.getSmallestSnapshot()
	for _, c := range compactions {
		edit := &manifest.Edit{
			LastSequence:   lastSequence,
			NextFileNumber: c.Registration.NextFileNumber,
		}
		compactor := compactor.NewLevelCompactor(db.name, smallestSequence, c, db.manifest, db.options)
		go db.compact(compactor, edit)
	}
}

func (db *DB) appendVersion(level int, version *manifest.Version) {
	defer db.wakeupWrite(level)
	db.mu.Lock()
	defer db.mu.Unlock()
	db.manifest.Append(version)
	if level == -1 {
		db.imm = nil
	}
}

func (db *DB) serveCompaction(done chan struct{}) {
	go db.serveVersionEdit(db.manifest.Current())
	defer close(done)
	defer close(db.compactionEdit)
	var registry compaction.Registry
	var ongoingObsoleteFiles chan struct{}
	var pendingMemtable *memtable.MemTable
	var compactionErr, manifestErr error
	var pendingFiles [configs.NumberLevels - 1]manifest.FileList
	closing := db.bgClosing
	pendingObsoleteFiles := db.manifest.NextFileNumber()
	registry.Recap(db.options.CompactionConcurrency)
	for !(closing == nil && registry.Concurrency() == 0 && ongoingObsoleteFiles == nil && pendingObsoleteFiles == 0) {
		var pendingLevelCompaction bool
		select {
		case tableNumber := <-db.obsoleteFilesChan:
			pendingObsoleteFiles = db.updateObsoleteTableNumber(pendingObsoleteFiles, tableNumber)
		case <-ongoingObsoleteFiles:
			ongoingObsoleteFiles = nil
		case <-closing:
			closing = nil
		case edit := <-db.memtableEdit:
			output := edit.AddedFiles[0].FileMeta
			maxLevel := db.manifest.Current().PickLevelForMemTableOutput(output.Smallest, output.Largest)
			if maxLevel > 0 {
				edit.AddedFiles[0].Level = registry.ExpandTo(-1, maxLevel)
			}
			db.compactionEdit <- compactionEdit{level: -1, edit: edit}
		case mem := <-db.compactionMemtable:
			pendingMemtable = mem
		case file := <-db.compactionFile:
			pendingFiles[file.Level] = append(pendingFiles[file.Level], file.FileMeta)
			pendingLevelCompaction = true
		case result := <-db.compactionResult:
			switch {
			case result.err == nil:
				db.appendVersion(result.level, result.version)
				registry.Complete(result.level)
				pendingObsoleteFiles = db.updateObsoleteTableNumber(pendingObsoleteFiles, registry.NextFileNumber(0))
				pendingLevelCompaction = true
			case result.version == nil:
				if compactionErr == nil {
					compactionErr = result.err
					db.compactionErrChan <- compactionErr
				}
				registry.Complete(result.level)
				pendingObsoleteFiles = db.updateObsoleteTableNumber(pendingObsoleteFiles, registry.NextFileNumber(0))
			default:
				if manifestErr == nil {
					manifestErr = result.err
					db.manifestErrChan <- manifestErr
				}
				// We don't known whether version edit was written or not,
				// so we can't collect table files generated by this compaction.
				registry.Corrupt(result.level)
			}
		}
		if pendingMemtable != nil && db.startMemTableCompaction(&registry, pendingMemtable) {
			pendingMemtable = nil
		}
		if pendingLevelCompaction {
			compactions := db.manifest.PickCompactions(&registry, pendingFiles[:])
			db.startLevelCompactions(compactions)
		}
		if pendingObsoleteFiles != 0 && ongoingObsoleteFiles == nil {
			ongoingObsoleteFiles = make(chan struct{})
			go db.removeObsoleteFiles(pendingObsoleteFiles, db.manifest.LogFileNumber(), db.manifest.ManifestFileNumber(), ongoingObsoleteFiles)
			pendingObsoleteFiles = 0
		}
	}
}

func (db *DB) serveVersionEdit(tip *manifest.Version) {
	var lastErr error
	for edit := range db.compactionEdit {
		next, err := db.manifest.Log(tip, edit.edit)
		if err != nil {
			lastErr = err
			db.compactionResult <- compactionResult{err: err, level: edit.level, version: tip}
			break
		}
		tip = next
		db.compactionResult <- compactionResult{level: edit.level, version: tip}
	}
	if lastErr != nil {
		for edit := range db.compactionEdit {
			db.compactionResult <- compactionResult{err: lastErr, level: edit.level, version: tip}
		}
	}
}
